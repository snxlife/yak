/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* import { Span } from '../src/error/span.ts'
* ---
* File := {body=Defition* $} | {body=Expr $} 
* _ := '\s*'
* IdentPart  := {'r#' raw=_IdentRaw
*                 .str = string {
*                     const str = "r#" + this.raw.str
*                     this.raw = undefined as any
*                     return str
*                 }} | str='[a-zA-Z_][a-zA-Z_0-9]*'
* _IdentRaw  := {str='#' | {raw='\S' next=_IdentRaw
*                 .str = string {
*                     const s = ({ raw, next }: any): string => next ? raw + next.str : "#"
*                     return s(this)
*                 }
*              }}
* Ident      := begin=@ part=IdentPart tail={'::' part=IdentPart}*  end=@
*                 .str = string {
*                     return this.tail.reduce((a: string, b: any): string => a + "::" + b.part.str, this.part.str)
*                 }
*                 .span = Span { return new Span(this.begin, this.end) }
* TypedIdent := begin=@ Ident {_ ':' _ Type}? end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Unit := begin=@ 'unit' end=@
*         .span = Span { return new Span(this.begin, this.end) }
* Type := ty=Unit | ty=Placeholder
* Attribute := begin=@ '@' _ name=Ident end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Defition :=
*             attrs={Attribute _}*
*             begin=@ 'def' _ name=Ident _ '\(' _
*                 arg0=TypedIdent? args={_ ',' _ arg=TypedIdent}* _ ','? _ 
*             '\)' {_ '->' _ ty=Type}? _ ':' end=@ _ body=Block
*             .span = Span { return new Span(this.begin, this.end) }
* Block := begin=@ stmts={stmt=Stmt _ ';' _}* expr=Expr end=@
*             .span = Span { return new Span(this.begin, this.end) }
* ReturnStmt := begin=@ 'return' _ expr=Expr end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Stmt       := stmt=ReturnStmt | stmt=Expr
* Expr        := begin=@ expr=Term end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Term        := begin=@ expr={{expr=Factor _ op={'\*' | '\/'} _ next=Term} | expr=Factor} end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Factor      := begin=@ expr={{expr=Call _ op={'\+' | '\-'} _ next=Factor} | expr=Call} end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Call        := begin=@ expr=Unary tail={_ expr=Dot | expr=CallParen}* end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Dot         := '.' _ expr=Unary
* CallParen   := '\(' _ first=Expr? last={_ ',' _ expr=Expr}* _ ','? _ '\)'
* Unary       := begin=@ op={prefix='\+' | '\-' | '\!' _}* expr=Binary end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Binary      := begin=@ expr={bin=Num | bin=Ident | bin=Placeholder | {'\(' _ bin=Expr _ '\)'}} end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Placeholder := begin=@ '\.\.\.' end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Ignore      := begin=@ '_' end=@
*                 .span = Span { return new Span(this.begin, this.end) }
* Num         := begin=@ num_str='(\.\d+)|(\d+(\.\d*)?)' end=@
*                 .span = Span { return new Span(this.begin, this.end) }
*                 .num = number { return parseFloat(this.num_str) }
*/


import { Span } from '../src/error/span.ts'


type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    File_1 = "File_1",
    File_2 = "File_2",
    File_$0 = "File_$0",
    File_$1 = "File_$1",
    _ = "_",
    IdentPart_1 = "IdentPart_1",
    IdentPart_2 = "IdentPart_2",
    IdentPart_$0 = "IdentPart_$0",
    _IdentRaw = "_IdentRaw",
    _IdentRaw_$0_1 = "_IdentRaw_$0_1",
    _IdentRaw_$0_2 = "_IdentRaw_$0_2",
    _IdentRaw_$0_$0 = "_IdentRaw_$0_$0",
    Ident = "Ident",
    Ident_$0 = "Ident_$0",
    TypedIdent = "TypedIdent",
    TypedIdent_$0 = "TypedIdent_$0",
    Unit = "Unit",
    Type_1 = "Type_1",
    Type_2 = "Type_2",
    Attribute = "Attribute",
    Defition = "Defition",
    Defition_$0 = "Defition_$0",
    Defition_$1 = "Defition_$1",
    Defition_$2 = "Defition_$2",
    Block = "Block",
    Block_$0 = "Block_$0",
    ReturnStmt = "ReturnStmt",
    Stmt_1 = "Stmt_1",
    Stmt_2 = "Stmt_2",
    Expr = "Expr",
    Term = "Term",
    Term_$0_1 = "Term_$0_1",
    Term_$0_2 = "Term_$0_2",
    Term_$0_$0 = "Term_$0_$0",
    Term_$0_$0_$0_1 = "Term_$0_$0_$0_1",
    Term_$0_$0_$0_2 = "Term_$0_$0_$0_2",
    Factor = "Factor",
    Factor_$0_1 = "Factor_$0_1",
    Factor_$0_2 = "Factor_$0_2",
    Factor_$0_$0 = "Factor_$0_$0",
    Factor_$0_$0_$0_1 = "Factor_$0_$0_$0_1",
    Factor_$0_$0_$0_2 = "Factor_$0_$0_$0_2",
    Call = "Call",
    Call_$0_1 = "Call_$0_1",
    Call_$0_2 = "Call_$0_2",
    Dot = "Dot",
    CallParen = "CallParen",
    CallParen_$0 = "CallParen_$0",
    Unary = "Unary",
    Unary_$0_1 = "Unary_$0_1",
    Unary_$0_2 = "Unary_$0_2",
    Unary_$0_3 = "Unary_$0_3",
    Binary = "Binary",
    Binary_$0_1 = "Binary_$0_1",
    Binary_$0_2 = "Binary_$0_2",
    Binary_$0_3 = "Binary_$0_3",
    Binary_$0_4 = "Binary_$0_4",
    Binary_$0_$0 = "Binary_$0_$0",
    Placeholder = "Placeholder",
    Ignore = "Ignore",
    Num = "Num",
    $EOF = "$EOF",
}
export type File = File_1 | File_2;
export type File_1 = File_$0;
export type File_2 = File_$1;
export interface File_$0 {
    kind: ASTKinds.File_$0;
    body: Defition[];
}
export interface File_$1 {
    kind: ASTKinds.File_$1;
    body: Expr;
}
export type _ = string;
export type IdentPart = IdentPart_1 | IdentPart_2;
export type IdentPart_1 = IdentPart_$0;
export interface IdentPart_2 {
    kind: ASTKinds.IdentPart_2;
    str: string;
}
export class IdentPart_$0 {
    kind: ASTKinds.IdentPart_$0 = ASTKinds.IdentPart_$0;
    raw: _IdentRaw;
    str: string;
    constructor(raw: _IdentRaw){
        this.raw = raw;
        this.str = ((): string => {
        const str = "r#" + this.raw.str
                    this.raw = undefined as any
                    return str
        })();
    }
}
export type _IdentRaw = _IdentRaw_$0;
export type _IdentRaw_$0 = _IdentRaw_$0_1 | _IdentRaw_$0_2;
export interface _IdentRaw_$0_1 {
    kind: ASTKinds._IdentRaw_$0_1;
    str: string;
}
export type _IdentRaw_$0_2 = _IdentRaw_$0_$0;
export class _IdentRaw_$0_$0 {
    kind: ASTKinds._IdentRaw_$0_$0 = ASTKinds._IdentRaw_$0_$0;
    raw: string;
    next: _IdentRaw;
    str: string;
    constructor(raw: string, next: _IdentRaw){
        this.raw = raw;
        this.next = next;
        this.str = ((): string => {
        const s = ({ raw, next }: any): string => next ? raw + next.str : "#"
                    return s(this)
        })();
    }
}
export class Ident {
    kind: ASTKinds.Ident = ASTKinds.Ident;
    begin: PosInfo;
    part: IdentPart;
    tail: Ident_$0[];
    end: PosInfo;
    str: string;
    span: Span;
    constructor(begin: PosInfo, part: IdentPart, tail: Ident_$0[], end: PosInfo){
        this.begin = begin;
        this.part = part;
        this.tail = tail;
        this.end = end;
        this.str = ((): string => {
        return this.tail.reduce((a: string, b: any): string => a + "::" + b.part.str, this.part.str)
        })();
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export interface Ident_$0 {
    kind: ASTKinds.Ident_$0;
    part: IdentPart;
}
export class TypedIdent {
    kind: ASTKinds.TypedIdent = ASTKinds.TypedIdent;
    begin: PosInfo;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, end: PosInfo){
        this.begin = begin;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export interface TypedIdent_$0 {
    kind: ASTKinds.TypedIdent_$0;
}
export class Unit {
    kind: ASTKinds.Unit = ASTKinds.Unit;
    begin: PosInfo;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, end: PosInfo){
        this.begin = begin;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Type = Type_1 | Type_2;
export interface Type_1 {
    kind: ASTKinds.Type_1;
    ty: Unit;
}
export interface Type_2 {
    kind: ASTKinds.Type_2;
    ty: Placeholder;
}
export class Attribute {
    kind: ASTKinds.Attribute = ASTKinds.Attribute;
    begin: PosInfo;
    name: Ident;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, name: Ident, end: PosInfo){
        this.begin = begin;
        this.name = name;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export class Defition {
    kind: ASTKinds.Defition = ASTKinds.Defition;
    attrs: Defition_$0[];
    begin: PosInfo;
    name: Ident;
    arg0: Nullable<TypedIdent>;
    args: Defition_$1[];
    end: PosInfo;
    body: Block;
    span: Span;
    constructor(attrs: Defition_$0[], begin: PosInfo, name: Ident, arg0: Nullable<TypedIdent>, args: Defition_$1[], end: PosInfo, body: Block){
        this.attrs = attrs;
        this.begin = begin;
        this.name = name;
        this.arg0 = arg0;
        this.args = args;
        this.end = end;
        this.body = body;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export interface Defition_$0 {
    kind: ASTKinds.Defition_$0;
}
export interface Defition_$1 {
    kind: ASTKinds.Defition_$1;
    arg: TypedIdent;
}
export interface Defition_$2 {
    kind: ASTKinds.Defition_$2;
    ty: Type;
}
export class Block {
    kind: ASTKinds.Block = ASTKinds.Block;
    begin: PosInfo;
    stmts: Block_$0[];
    expr: Expr;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, stmts: Block_$0[], expr: Expr, end: PosInfo){
        this.begin = begin;
        this.stmts = stmts;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export interface Block_$0 {
    kind: ASTKinds.Block_$0;
    stmt: Stmt;
}
export class ReturnStmt {
    kind: ASTKinds.ReturnStmt = ASTKinds.ReturnStmt;
    begin: PosInfo;
    expr: Expr;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Expr, end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Stmt = Stmt_1 | Stmt_2;
export interface Stmt_1 {
    kind: ASTKinds.Stmt_1;
    stmt: ReturnStmt;
}
export interface Stmt_2 {
    kind: ASTKinds.Stmt_2;
    stmt: Expr;
}
export class Expr {
    kind: ASTKinds.Expr = ASTKinds.Expr;
    begin: PosInfo;
    expr: Term;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Term, end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export class Term {
    kind: ASTKinds.Term = ASTKinds.Term;
    begin: PosInfo;
    expr: Term_$0;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Term_$0, end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Term_$0 = Term_$0_1 | Term_$0_2;
export type Term_$0_1 = Term_$0_$0;
export interface Term_$0_2 {
    kind: ASTKinds.Term_$0_2;
    expr: Factor;
}
export interface Term_$0_$0 {
    kind: ASTKinds.Term_$0_$0;
    expr: Factor;
    op: Term_$0_$0_$0;
    next: Term;
}
export type Term_$0_$0_$0 = Term_$0_$0_$0_1 | Term_$0_$0_$0_2;
export type Term_$0_$0_$0_1 = string;
export type Term_$0_$0_$0_2 = string;
export class Factor {
    kind: ASTKinds.Factor = ASTKinds.Factor;
    begin: PosInfo;
    expr: Factor_$0;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Factor_$0, end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Factor_$0 = Factor_$0_1 | Factor_$0_2;
export type Factor_$0_1 = Factor_$0_$0;
export interface Factor_$0_2 {
    kind: ASTKinds.Factor_$0_2;
    expr: Call;
}
export interface Factor_$0_$0 {
    kind: ASTKinds.Factor_$0_$0;
    expr: Call;
    op: Factor_$0_$0_$0;
    next: Factor;
}
export type Factor_$0_$0_$0 = Factor_$0_$0_$0_1 | Factor_$0_$0_$0_2;
export type Factor_$0_$0_$0_1 = string;
export type Factor_$0_$0_$0_2 = string;
export class Call {
    kind: ASTKinds.Call = ASTKinds.Call;
    begin: PosInfo;
    expr: Unary;
    tail: Call_$0[];
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Unary, tail: Call_$0[], end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.tail = tail;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Call_$0 = Call_$0_1 | Call_$0_2;
export interface Call_$0_1 {
    kind: ASTKinds.Call_$0_1;
    expr: Dot;
}
export interface Call_$0_2 {
    kind: ASTKinds.Call_$0_2;
    expr: CallParen;
}
export interface Dot {
    kind: ASTKinds.Dot;
    expr: Unary;
}
export interface CallParen {
    kind: ASTKinds.CallParen;
    first: Nullable<Expr>;
    last: CallParen_$0[];
}
export interface CallParen_$0 {
    kind: ASTKinds.CallParen_$0;
    expr: Expr;
}
export class Unary {
    kind: ASTKinds.Unary = ASTKinds.Unary;
    begin: PosInfo;
    op: Unary_$0[];
    expr: Binary;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, op: Unary_$0[], expr: Binary, end: PosInfo){
        this.begin = begin;
        this.op = op;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Unary_$0 = Unary_$0_1 | Unary_$0_2 | Unary_$0_3;
export interface Unary_$0_1 {
    kind: ASTKinds.Unary_$0_1;
    prefix: string;
}
export type Unary_$0_2 = string;
export interface Unary_$0_3 {
    kind: ASTKinds.Unary_$0_3;
}
export class Binary {
    kind: ASTKinds.Binary = ASTKinds.Binary;
    begin: PosInfo;
    expr: Binary_$0;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, expr: Binary_$0, end: PosInfo){
        this.begin = begin;
        this.expr = expr;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export type Binary_$0 = Binary_$0_1 | Binary_$0_2 | Binary_$0_3 | Binary_$0_4;
export interface Binary_$0_1 {
    kind: ASTKinds.Binary_$0_1;
    bin: Num;
}
export interface Binary_$0_2 {
    kind: ASTKinds.Binary_$0_2;
    bin: Ident;
}
export interface Binary_$0_3 {
    kind: ASTKinds.Binary_$0_3;
    bin: Placeholder;
}
export type Binary_$0_4 = Binary_$0_$0;
export interface Binary_$0_$0 {
    kind: ASTKinds.Binary_$0_$0;
    bin: Expr;
}
export class Placeholder {
    kind: ASTKinds.Placeholder = ASTKinds.Placeholder;
    begin: PosInfo;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, end: PosInfo){
        this.begin = begin;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export class Ignore {
    kind: ASTKinds.Ignore = ASTKinds.Ignore;
    begin: PosInfo;
    end: PosInfo;
    span: Span;
    constructor(begin: PosInfo, end: PosInfo){
        this.begin = begin;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
    }
}
export class Num {
    kind: ASTKinds.Num = ASTKinds.Num;
    begin: PosInfo;
    num_str: string;
    end: PosInfo;
    span: Span;
    num: number;
    constructor(begin: PosInfo, num_str: string, end: PosInfo){
        this.begin = begin;
        this.num_str = num_str;
        this.end = end;
        this.span = ((): Span => {
        return new Span(this.begin, this.end)
        })();
        this.num = ((): number => {
        return parseFloat(this.num_str)
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating = false;
    private memoSafe = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    reset(pos: PosInfo) {
        this.pos = pos;
    }
    finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    clearMemos(): void {
    }
    matchFile($$dpth: number, $$cr?: ErrorTracker): Nullable<File> {
        return this.choice<File>([
            () => this.matchFile_1($$dpth + 1, $$cr),
            () => this.matchFile_2($$dpth + 1, $$cr),
        ]);
    }
    matchFile_1($$dpth: number, $$cr?: ErrorTracker): Nullable<File_1> {
        return this.matchFile_$0($$dpth + 1, $$cr);
    }
    matchFile_2($$dpth: number, $$cr?: ErrorTracker): Nullable<File_2> {
        return this.matchFile_$1($$dpth + 1, $$cr);
    }
    matchFile_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<File_$0> {
        return this.run<File_$0>($$dpth,
            () => {
                let $scope$body: Nullable<Defition[]>;
                let $$res: Nullable<File_$0> = null;
                if (true
                    && ($scope$body = this.loop<Defition>(() => this.matchDefition($$dpth + 1, $$cr), true)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.File_$0, body: $scope$body};
                }
                return $$res;
            });
    }
    matchFile_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<File_$1> {
        return this.run<File_$1>($$dpth,
            () => {
                let $scope$body: Nullable<Expr>;
                let $$res: Nullable<File_$1> = null;
                if (true
                    && ($scope$body = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.File_$1, body: $scope$body};
                }
                return $$res;
            });
    }
    match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.regexAccept(String.raw`(?:\s*)`, $$dpth + 1, $$cr);
    }
    matchIdentPart($$dpth: number, $$cr?: ErrorTracker): Nullable<IdentPart> {
        return this.choice<IdentPart>([
            () => this.matchIdentPart_1($$dpth + 1, $$cr),
            () => this.matchIdentPart_2($$dpth + 1, $$cr),
        ]);
    }
    matchIdentPart_1($$dpth: number, $$cr?: ErrorTracker): Nullable<IdentPart_1> {
        return this.matchIdentPart_$0($$dpth + 1, $$cr);
    }
    matchIdentPart_2($$dpth: number, $$cr?: ErrorTracker): Nullable<IdentPart_2> {
        return this.run<IdentPart_2>($$dpth,
            () => {
                let $scope$str: Nullable<string>;
                let $$res: Nullable<IdentPart_2> = null;
                if (true
                    && ($scope$str = this.regexAccept(String.raw`(?:[a-zA-Z_][a-zA-Z_0-9]*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IdentPart_2, str: $scope$str};
                }
                return $$res;
            });
    }
    matchIdentPart_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<IdentPart_$0> {
        return this.run<IdentPart_$0>($$dpth,
            () => {
                let $scope$raw: Nullable<_IdentRaw>;
                let $$res: Nullable<IdentPart_$0> = null;
                if (true
                    && this.regexAccept(String.raw`(?:r#)`, $$dpth + 1, $$cr) !== null
                    && ($scope$raw = this.match_IdentRaw($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new IdentPart_$0($scope$raw);
                }
                return $$res;
            });
    }
    match_IdentRaw($$dpth: number, $$cr?: ErrorTracker): Nullable<_IdentRaw> {
        return this.match_IdentRaw_$0($$dpth + 1, $$cr);
    }
    match_IdentRaw_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<_IdentRaw_$0> {
        return this.choice<_IdentRaw_$0>([
            () => this.match_IdentRaw_$0_1($$dpth + 1, $$cr),
            () => this.match_IdentRaw_$0_2($$dpth + 1, $$cr),
        ]);
    }
    match_IdentRaw_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<_IdentRaw_$0_1> {
        return this.run<_IdentRaw_$0_1>($$dpth,
            () => {
                let $scope$str: Nullable<string>;
                let $$res: Nullable<_IdentRaw_$0_1> = null;
                if (true
                    && ($scope$str = this.regexAccept(String.raw`(?:#)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds._IdentRaw_$0_1, str: $scope$str};
                }
                return $$res;
            });
    }
    match_IdentRaw_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<_IdentRaw_$0_2> {
        return this.match_IdentRaw_$0_$0($$dpth + 1, $$cr);
    }
    match_IdentRaw_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<_IdentRaw_$0_$0> {
        return this.run<_IdentRaw_$0_$0>($$dpth,
            () => {
                let $scope$raw: Nullable<string>;
                let $scope$next: Nullable<_IdentRaw>;
                let $$res: Nullable<_IdentRaw_$0_$0> = null;
                if (true
                    && ($scope$raw = this.regexAccept(String.raw`(?:\S)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.match_IdentRaw($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new _IdentRaw_$0_$0($scope$raw, $scope$next);
                }
                return $$res;
            });
    }
    matchIdent($$dpth: number, $$cr?: ErrorTracker): Nullable<Ident> {
        return this.run<Ident>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$part: Nullable<IdentPart>;
                let $scope$tail: Nullable<Ident_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Ident> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$part = this.matchIdentPart($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Ident_$0>(() => this.matchIdent_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Ident($scope$begin, $scope$part, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    matchIdent_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Ident_$0> {
        return this.run<Ident_$0>($$dpth,
            () => {
                let $scope$part: Nullable<IdentPart>;
                let $$res: Nullable<Ident_$0> = null;
                if (true
                    && this.regexAccept(String.raw`(?:::)`, $$dpth + 1, $$cr) !== null
                    && ($scope$part = this.matchIdentPart($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Ident_$0, part: $scope$part};
                }
                return $$res;
            });
    }
    matchTypedIdent($$dpth: number, $$cr?: ErrorTracker): Nullable<TypedIdent> {
        return this.run<TypedIdent>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<TypedIdent> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.matchIdent($$dpth + 1, $$cr) !== null
                    && ((this.matchTypedIdent_$0($$dpth + 1, $$cr)) || true)
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new TypedIdent($scope$begin, $scope$end);
                }
                return $$res;
            });
    }
    matchTypedIdent_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<TypedIdent_$0> {
        return this.run<TypedIdent_$0>($$dpth,
            () => {
                let $$res: Nullable<TypedIdent_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchType($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.TypedIdent_$0, };
                }
                return $$res;
            });
    }
    matchUnit($$dpth: number, $$cr?: ErrorTracker): Nullable<Unit> {
        return this.run<Unit>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Unit> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:unit)`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Unit($scope$begin, $scope$end);
                }
                return $$res;
            });
    }
    matchType($$dpth: number, $$cr?: ErrorTracker): Nullable<Type> {
        return this.choice<Type>([
            () => this.matchType_1($$dpth + 1, $$cr),
            () => this.matchType_2($$dpth + 1, $$cr),
        ]);
    }
    matchType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Type_1> {
        return this.run<Type_1>($$dpth,
            () => {
                let $scope$ty: Nullable<Unit>;
                let $$res: Nullable<Type_1> = null;
                if (true
                    && ($scope$ty = this.matchUnit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Type_1, ty: $scope$ty};
                }
                return $$res;
            });
    }
    matchType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Type_2> {
        return this.run<Type_2>($$dpth,
            () => {
                let $scope$ty: Nullable<Placeholder>;
                let $$res: Nullable<Type_2> = null;
                if (true
                    && ($scope$ty = this.matchPlaceholder($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Type_2, ty: $scope$ty};
                }
                return $$res;
            });
    }
    matchAttribute($$dpth: number, $$cr?: ErrorTracker): Nullable<Attribute> {
        return this.run<Attribute>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$name: Nullable<Ident>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Attribute> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:@)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchIdent($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Attribute($scope$begin, $scope$name, $scope$end);
                }
                return $$res;
            });
    }
    matchDefition($$dpth: number, $$cr?: ErrorTracker): Nullable<Defition> {
        return this.run<Defition>($$dpth,
            () => {
                let $scope$attrs: Nullable<Defition_$0[]>;
                let $scope$begin: Nullable<PosInfo>;
                let $scope$name: Nullable<Ident>;
                let $scope$arg0: Nullable<Nullable<TypedIdent>>;
                let $scope$args: Nullable<Defition_$1[]>;
                let $scope$end: Nullable<PosInfo>;
                let $scope$body: Nullable<Block>;
                let $$res: Nullable<Defition> = null;
                if (true
                    && ($scope$attrs = this.loop<Defition_$0>(() => this.matchDefition_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:def)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchIdent($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$arg0 = this.matchTypedIdent($$dpth + 1, $$cr)) || true)
                    && ($scope$args = this.loop<Defition_$1>(() => this.matchDefition_$1($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                    && ((this.matchDefition_$2($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$body = this.matchBlock($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Defition($scope$attrs, $scope$begin, $scope$name, $scope$arg0, $scope$args, $scope$end, $scope$body);
                }
                return $$res;
            });
    }
    matchDefition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Defition_$0> {
        return this.run<Defition_$0>($$dpth,
            () => {
                let $$res: Nullable<Defition_$0> = null;
                if (true
                    && this.matchAttribute($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Defition_$0, };
                }
                return $$res;
            });
    }
    matchDefition_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<Defition_$1> {
        return this.run<Defition_$1>($$dpth,
            () => {
                let $scope$arg: Nullable<TypedIdent>;
                let $$res: Nullable<Defition_$1> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$arg = this.matchTypedIdent($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Defition_$1, arg: $scope$arg};
                }
                return $$res;
            });
    }
    matchDefition_$2($$dpth: number, $$cr?: ErrorTracker): Nullable<Defition_$2> {
        return this.run<Defition_$2>($$dpth,
            () => {
                let $scope$ty: Nullable<Type>;
                let $$res: Nullable<Defition_$2> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:->)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$ty = this.matchType($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Defition_$2, ty: $scope$ty};
                }
                return $$res;
            });
    }
    matchBlock($$dpth: number, $$cr?: ErrorTracker): Nullable<Block> {
        return this.run<Block>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$stmts: Nullable<Block_$0[]>;
                let $scope$expr: Nullable<Expr>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Block> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$stmts = this.loop<Block_$0>(() => this.matchBlock_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Block($scope$begin, $scope$stmts, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchBlock_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Block_$0> {
        return this.run<Block_$0>($$dpth,
            () => {
                let $scope$stmt: Nullable<Stmt>;
                let $$res: Nullable<Block_$0> = null;
                if (true
                    && ($scope$stmt = this.matchStmt($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Block_$0, stmt: $scope$stmt};
                }
                return $$res;
            });
    }
    matchReturnStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<ReturnStmt> {
        return this.run<ReturnStmt>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Expr>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<ReturnStmt> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:return)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new ReturnStmt($scope$begin, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<Stmt> {
        return this.choice<Stmt>([
            () => this.matchStmt_1($$dpth + 1, $$cr),
            () => this.matchStmt_2($$dpth + 1, $$cr),
        ]);
    }
    matchStmt_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Stmt_1> {
        return this.run<Stmt_1>($$dpth,
            () => {
                let $scope$stmt: Nullable<ReturnStmt>;
                let $$res: Nullable<Stmt_1> = null;
                if (true
                    && ($scope$stmt = this.matchReturnStmt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Stmt_1, stmt: $scope$stmt};
                }
                return $$res;
            });
    }
    matchStmt_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Stmt_2> {
        return this.run<Stmt_2>($$dpth,
            () => {
                let $scope$stmt: Nullable<Expr>;
                let $$res: Nullable<Stmt_2> = null;
                if (true
                    && ($scope$stmt = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Stmt_2, stmt: $scope$stmt};
                }
                return $$res;
            });
    }
    matchExpr($$dpth: number, $$cr?: ErrorTracker): Nullable<Expr> {
        return this.run<Expr>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Term>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Expr> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$expr = this.matchTerm($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Expr($scope$begin, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchTerm($$dpth: number, $$cr?: ErrorTracker): Nullable<Term> {
        return this.run<Term>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Term_$0>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Term> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$expr = this.matchTerm_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Term($scope$begin, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchTerm_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0> {
        return this.choice<Term_$0>([
            () => this.matchTerm_$0_1($$dpth + 1, $$cr),
            () => this.matchTerm_$0_2($$dpth + 1, $$cr),
        ]);
    }
    matchTerm_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_1> {
        return this.matchTerm_$0_$0($$dpth + 1, $$cr);
    }
    matchTerm_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_2> {
        return this.run<Term_$0_2>($$dpth,
            () => {
                let $scope$expr: Nullable<Factor>;
                let $$res: Nullable<Term_$0_2> = null;
                if (true
                    && ($scope$expr = this.matchFactor($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Term_$0_2, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchTerm_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_$0> {
        return this.run<Term_$0_$0>($$dpth,
            () => {
                let $scope$expr: Nullable<Factor>;
                let $scope$op: Nullable<Term_$0_$0_$0>;
                let $scope$next: Nullable<Term>;
                let $$res: Nullable<Term_$0_$0> = null;
                if (true
                    && ($scope$expr = this.matchFactor($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchTerm_$0_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$next = this.matchTerm($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Term_$0_$0, expr: $scope$expr, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    matchTerm_$0_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_$0_$0> {
        return this.choice<Term_$0_$0_$0>([
            () => this.matchTerm_$0_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchTerm_$0_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    matchTerm_$0_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_$0_$0_1> {
        return this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr);
    }
    matchTerm_$0_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Term_$0_$0_$0_2> {
        return this.regexAccept(String.raw`(?:\/)`, $$dpth + 1, $$cr);
    }
    matchFactor($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor> {
        return this.run<Factor>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Factor_$0>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Factor> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$expr = this.matchFactor_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Factor($scope$begin, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchFactor_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0> {
        return this.choice<Factor_$0>([
            () => this.matchFactor_$0_1($$dpth + 1, $$cr),
            () => this.matchFactor_$0_2($$dpth + 1, $$cr),
        ]);
    }
    matchFactor_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_1> {
        return this.matchFactor_$0_$0($$dpth + 1, $$cr);
    }
    matchFactor_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_2> {
        return this.run<Factor_$0_2>($$dpth,
            () => {
                let $scope$expr: Nullable<Call>;
                let $$res: Nullable<Factor_$0_2> = null;
                if (true
                    && ($scope$expr = this.matchCall($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Factor_$0_2, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchFactor_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_$0> {
        return this.run<Factor_$0_$0>($$dpth,
            () => {
                let $scope$expr: Nullable<Call>;
                let $scope$op: Nullable<Factor_$0_$0_$0>;
                let $scope$next: Nullable<Factor>;
                let $$res: Nullable<Factor_$0_$0> = null;
                if (true
                    && ($scope$expr = this.matchCall($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchFactor_$0_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$next = this.matchFactor($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Factor_$0_$0, expr: $scope$expr, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    matchFactor_$0_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_$0_$0> {
        return this.choice<Factor_$0_$0_$0>([
            () => this.matchFactor_$0_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchFactor_$0_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    matchFactor_$0_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_$0_$0_1> {
        return this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr);
    }
    matchFactor_$0_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Factor_$0_$0_$0_2> {
        return this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr);
    }
    matchCall($$dpth: number, $$cr?: ErrorTracker): Nullable<Call> {
        return this.run<Call>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Unary>;
                let $scope$tail: Nullable<Call_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Call> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$expr = this.matchUnary($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Call_$0>(() => this.matchCall_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Call($scope$begin, $scope$expr, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    matchCall_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Call_$0> {
        return this.choice<Call_$0>([
            () => this.matchCall_$0_1($$dpth + 1, $$cr),
            () => this.matchCall_$0_2($$dpth + 1, $$cr),
        ]);
    }
    matchCall_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Call_$0_1> {
        return this.run<Call_$0_1>($$dpth,
            () => {
                let $scope$expr: Nullable<Dot>;
                let $$res: Nullable<Call_$0_1> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchDot($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Call_$0_1, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchCall_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Call_$0_2> {
        return this.run<Call_$0_2>($$dpth,
            () => {
                let $scope$expr: Nullable<CallParen>;
                let $$res: Nullable<Call_$0_2> = null;
                if (true
                    && ($scope$expr = this.matchCallParen($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Call_$0_2, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchDot($$dpth: number, $$cr?: ErrorTracker): Nullable<Dot> {
        return this.run<Dot>($$dpth,
            () => {
                let $scope$expr: Nullable<Unary>;
                let $$res: Nullable<Dot> = null;
                if (true
                    && this.regexAccept(String.raw`(?:.)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchUnary($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Dot, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchCallParen($$dpth: number, $$cr?: ErrorTracker): Nullable<CallParen> {
        return this.run<CallParen>($$dpth,
            () => {
                let $scope$first: Nullable<Nullable<Expr>>;
                let $scope$last: Nullable<CallParen_$0[]>;
                let $$res: Nullable<CallParen> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$first = this.matchExpr($$dpth + 1, $$cr)) || true)
                    && ($scope$last = this.loop<CallParen_$0>(() => this.matchCallParen_$0($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.CallParen, first: $scope$first, last: $scope$last};
                }
                return $$res;
            });
    }
    matchCallParen_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<CallParen_$0> {
        return this.run<CallParen_$0>($$dpth,
            () => {
                let $scope$expr: Nullable<Expr>;
                let $$res: Nullable<CallParen_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.CallParen_$0, expr: $scope$expr};
                }
                return $$res;
            });
    }
    matchUnary($$dpth: number, $$cr?: ErrorTracker): Nullable<Unary> {
        return this.run<Unary>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$op: Nullable<Unary_$0[]>;
                let $scope$expr: Nullable<Binary>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Unary> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$op = this.loop<Unary_$0>(() => this.matchUnary_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$expr = this.matchBinary($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Unary($scope$begin, $scope$op, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchUnary_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Unary_$0> {
        return this.choice<Unary_$0>([
            () => this.matchUnary_$0_1($$dpth + 1, $$cr),
            () => this.matchUnary_$0_2($$dpth + 1, $$cr),
            () => this.matchUnary_$0_3($$dpth + 1, $$cr),
        ]);
    }
    matchUnary_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Unary_$0_1> {
        return this.run<Unary_$0_1>($$dpth,
            () => {
                let $scope$prefix: Nullable<string>;
                let $$res: Nullable<Unary_$0_1> = null;
                if (true
                    && ($scope$prefix = this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Unary_$0_1, prefix: $scope$prefix};
                }
                return $$res;
            });
    }
    matchUnary_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Unary_$0_2> {
        return this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr);
    }
    matchUnary_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Unary_$0_3> {
        return this.run<Unary_$0_3>($$dpth,
            () => {
                let $$res: Nullable<Unary_$0_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\!)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Unary_$0_3, };
                }
                return $$res;
            });
    }
    matchBinary($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary> {
        return this.run<Binary>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$expr: Nullable<Binary_$0>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Binary> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$expr = this.matchBinary_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Binary($scope$begin, $scope$expr, $scope$end);
                }
                return $$res;
            });
    }
    matchBinary_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0> {
        return this.choice<Binary_$0>([
            () => this.matchBinary_$0_1($$dpth + 1, $$cr),
            () => this.matchBinary_$0_2($$dpth + 1, $$cr),
            () => this.matchBinary_$0_3($$dpth + 1, $$cr),
            () => this.matchBinary_$0_4($$dpth + 1, $$cr),
        ]);
    }
    matchBinary_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0_1> {
        return this.run<Binary_$0_1>($$dpth,
            () => {
                let $scope$bin: Nullable<Num>;
                let $$res: Nullable<Binary_$0_1> = null;
                if (true
                    && ($scope$bin = this.matchNum($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Binary_$0_1, bin: $scope$bin};
                }
                return $$res;
            });
    }
    matchBinary_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0_2> {
        return this.run<Binary_$0_2>($$dpth,
            () => {
                let $scope$bin: Nullable<Ident>;
                let $$res: Nullable<Binary_$0_2> = null;
                if (true
                    && ($scope$bin = this.matchIdent($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Binary_$0_2, bin: $scope$bin};
                }
                return $$res;
            });
    }
    matchBinary_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0_3> {
        return this.run<Binary_$0_3>($$dpth,
            () => {
                let $scope$bin: Nullable<Placeholder>;
                let $$res: Nullable<Binary_$0_3> = null;
                if (true
                    && ($scope$bin = this.matchPlaceholder($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Binary_$0_3, bin: $scope$bin};
                }
                return $$res;
            });
    }
    matchBinary_$0_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0_4> {
        return this.matchBinary_$0_$0($$dpth + 1, $$cr);
    }
    matchBinary_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Binary_$0_$0> {
        return this.run<Binary_$0_$0>($$dpth,
            () => {
                let $scope$bin: Nullable<Expr>;
                let $$res: Nullable<Binary_$0_$0> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$bin = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Binary_$0_$0, bin: $scope$bin};
                }
                return $$res;
            });
    }
    matchPlaceholder($$dpth: number, $$cr?: ErrorTracker): Nullable<Placeholder> {
        return this.run<Placeholder>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Placeholder> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:\.\.\.)`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Placeholder($scope$begin, $scope$end);
                }
                return $$res;
            });
    }
    matchIgnore($$dpth: number, $$cr?: ErrorTracker): Nullable<Ignore> {
        return this.run<Ignore>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Ignore> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:_)`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Ignore($scope$begin, $scope$end);
                }
                return $$res;
            });
    }
    matchNum($$dpth: number, $$cr?: ErrorTracker): Nullable<Num> {
        return this.run<Num>($$dpth,
            () => {
                let $scope$begin: Nullable<PosInfo>;
                let $scope$num_str: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Num> = null;
                if (true
                    && ($scope$begin = this.mark()) !== null
                    && ($scope$num_str = this.regexAccept(String.raw`(?:(\.\d+)|(\d+(\.\d*)?))`, $$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Num($scope$begin, $scope$num_str, $scope$end);
                }
                return $$res;
            });
    }
    test(): boolean {
        const mrk = this.mark();
        const res = this.matchFile(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchFile(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchFile(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<File>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    pos: PosInfo;
    expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}